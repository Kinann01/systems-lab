#include <uapi/linux/socket.h>
#include <uapi/linux/in.h>

/**
* track connect() to filter out dns traffic.we use a map 
* for that and set 1 to the corresponding fd this fd 
* will be used under sendmmsg() as a predicate.
*/
tracepoint:syscalls:sys_enter_connect
/ args->uservaddr != 0/
{
    $sa = (struct sockaddr_in*)args->uservaddr;
    $port = ($sa->sin_port >> 8) | (($sa->sin_port & 0xff) << 8); // network byte order to host byte order (little endian - uint16)

    if ($port != 53) { return; }

    if ($sa->sin_family != AF_INET) { return; } 

    @dns_sock[pid, args->fd] = 1;
    time("%Y-%m-%d %H:%M:%S ");
    printf("Tracing connect() ... uid=%d pid=%d comm=%s fd=%d - IPv4 connect to %s:%u\n", uid, pid, comm, args->fd, ntop($sa->sin_addr.s_addr), $port);
}

/**
* For DNS, we assume two messages within a single 
* sendmmsg() sys call. 'A' and 'AAAA'
*/
tracepoint:syscalls:sys_enter_sendmmsg 
/ @dns_sock[pid, args->fd] == 1 /
{
    time("%Y-%m-%d %H:%M:%S ");
    printf("Tracing sendmmsg() ... uid=%d pid=%d comm=%s fd=%d - contains %d messages\n", uid, pid, comm, args->fd, args->vlen);

    $limit = args->vlen;
    $base = args->mmsg;  

    $mmsghdr = $base[0]; 
    $iov_base = $mmsghdr.msg_hdr.msg_iov->iov_base;
    $iov_len = $mmsghdr.msg_hdr.msg_iov->iov_len;
    $buffer = buf($iov_base, $iov_len);
    printf("Dumping first message ==%r== \n", $buffer);

    $limit--;
    if ($limit == 0) { return; }

    $mmsghdr = $base[1]; 
    $iov_base = $mmsghdr.msg_hdr.msg_iov->iov_base;
    $iov_len = $mmsghdr.msg_hdr.msg_iov->iov_len;
    $buffer = buf($iov_base, $iov_len);
    printf("Dumping second message ==%r== \n", $buffer); 

    @dns_messages[pid, comm] += args->vlen;
}

/**
* free resources
*/
tracepoint:syscalls:sys_enter_close
/ @dns_sock[pid, args->fd] == 1 /
{
  delete(@dns_sock[pid, args->fd]);
}